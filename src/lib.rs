use clap::ArgEnum;
use color_eyre::{eyre::Report, Result};
use csv::Reader;
use serde::Deserialize;
use std::fmt;
use std::path::Path;
use url::Url;

pub mod cli;

/// Represent the PFB S3 storage base URL.
const PFB_S3_STORAGE_BASE_URL: &str =
    "https://s3.amazonaws.com/production-pfb-storage-us-east-1/results";

/// Represent the name of the "neighborhood ways" dataset.
const DS_NEIGHBORHOOD_WAYS: &str = "neighborhood_ways";
const DS_NEIGHBORHOOD_OVERALL_SCORES: &str = "neighborhood_overall_scores";

/// Setup the application.
///
/// Set up the `color_eyre` hooks.
pub fn setup() -> Result<(), Report> {
    color_eyre::install()?;

    Ok(())
}

/// Describe all the available city datasets.
#[derive(Debug, PartialEq, PartialOrd, ArgEnum, Clone, Copy)]
pub enum Dataset {
    NeighborhoodWays,
    NeighborhoodOverallScores,
}

impl From<&str> for Dataset {
    fn from(item: &str) -> Self {
        match item {
            DS_NEIGHBORHOOD_WAYS => Dataset::NeighborhoodWays,
            DS_NEIGHBORHOOD_OVERALL_SCORES => Dataset::NeighborhoodOverallScores,
            _ => panic!("Cannot parse dataset name {}", item),
        }
    }
}

impl fmt::Display for Dataset {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Dataset::NeighborhoodWays => write!(f, "{}", DS_NEIGHBORHOOD_WAYS),
            Dataset::NeighborhoodOverallScores => write!(f, "{}", DS_NEIGHBORHOOD_OVERALL_SCORES),
        }
    }
}

impl Dataset {
    pub fn extension(&self) -> String {
        match self {
            Dataset::NeighborhoodWays => String::from("zip"),
            Dataset::NeighborhoodOverallScores => String::from("csv"),
        }
    }
}

/// Define a PeopleForBikes city.
#[derive(Debug, Deserialize, Clone)]
pub struct City {
    /// City name.
    #[serde(rename = "City")]
    pub name: String,
    /// Country where the city is located.
    #[serde(rename = "Country")]
    pub country: String,
    /// State where the city is located.
    #[serde(rename = "State")]
    pub state: String,
    /// City's unique identifier.
    ///
    /// It is generated by a specific Bicyle Network Analysis (BNA) run and
    /// should be assimilated to a version number (each run will generate a
    /// new identifier).
    pub uuid: String,
    /// City's population.
    pub population: u32,
    /// City rating.
    #[serde(rename = "city_ratings_total")]
    pub ratings: f64,
    /// Rounded city rating.
    #[serde(rename = "city_ratings_rounded")]
    pub ratings_rounded: u8,
}
impl City {
    /// Create a new City.
    ///
    /// If the `state` is not specified (a lot of countries do not have states),
    /// the name of the country is used instead.
    pub fn new(
        name: &str,
        country: &str,
        state: Option<&str>,
        uuid: &str,
        population: u32,
        ratings: f64,
        ratings_rounded: u8,
    ) -> Self {
        City {
            name: name.into(),
            country: country.into(),
            state: if let Some(s) = state {
                s.into()
            } else {
                country.into()
            },
            uuid: uuid.into(),
            population,
            ratings,
            ratings_rounded,
        }
    }

    /// Return the full name of the city.
    ///
    /// The full name has the following format: `{COUNTRY}-{STATE}-{CITY_NAME}`.
    pub fn full_name(&self) -> String {
        format!("{}-{}-{}", self.country, self.state, self.name)
    }

    /// Return the URL of the specified dataset.
    pub fn url(&self, dataset: Dataset) -> Result<Url, Report> {
        let dataset_url = format!(
            "{}/{}/{}.{}",
            PFB_S3_STORAGE_BASE_URL,
            self.uuid,
            dataset,
            dataset.extension()
        );
        Ok(Url::parse(&dataset_url)?)
    }

    /// Read a CSV file and populate a Vector of Cities.
    ///
    /// The CSV file is expected to contain the following fields (case sensitive):
    /// * City
    /// * Country
    /// * State
    /// * uuid
    pub fn from_csv<P>(path: P) -> Result<Vec<City>, Report>
    where
        P: AsRef<Path>,
    {
        let mut csv_reader = Reader::from_path(path)?;
        let mut cities: Vec<City> = vec![];
        for record in csv_reader.deserialize() {
            cities.push(record?);
        }

        Ok(cities)
    }
}

/// Define a city scorecard.
#[derive(Debug, Deserialize, Clone)]
pub struct ScoreCard {
    /// City details.
    #[serde(flatten)]
    pub city: City,
    /// Community survey results.
    #[serde(flatten)]
    pub community_survey: CommunitySurvey,
    /// BNA results.
    #[serde(flatten)]
    pub bna: BNA,
    /// Infrastructure details.
    #[serde(flatten)]
    pub infrastructure: Infrastructure,
}

impl ScoreCard {
    /// Read a CSV file and populate a Vector of ScoreCards.
    pub fn from_csv<P>(path: P) -> Result<Vec<ScoreCard>, Report>
    where
        P: AsRef<Path>,
    {
        let mut csv_reader = Reader::from_path(path)?;
        let mut scorecards: Vec<ScoreCard> = vec![];
        for record in csv_reader.deserialize() {
            scorecards.push(record?);
        }

        Ok(scorecards)
    }
}
/// Represent the results from the community survey.
#[derive(Debug, Deserialize, Clone)]
pub struct CommunitySurvey {
    /// Perception of the quality of the bicycle network in the city.
    #[serde(rename = "Community Survey - Network")]
    pub network: f64,
    /// Perceptions of acceleration and awareness of bike events and facilities in an area.
    #[serde(rename = "Community Survey - Awareness")]
    pub awareness: f64,
    /// Perceptions of safety riding a bike .
    #[serde(rename = "Community Survey - Safety")]
    pub safety: f64,
    /// Measure how often respondents engage in different types of riding.
    #[serde(rename = "Community Survey - Ridership")]
    pub ridership: f64,
    /// Overall community survey score.
    #[serde(rename = "Community Score - Total")]
    pub total: f64,
    /// Overall community survey rounded score.
    #[serde(rename = "Community Score - Total, Rounded")]
    pub total_rounded: u32,
    /// Number of responses to the survey.
    #[serde(rename = "Community Survey - Responses")]
    pub responses: u32,
}

/// Represent the results from the BNA.
#[derive(Debug, Deserialize, Clone)]
pub struct BNA {
    /// How well people can reach other people by bike.
    #[serde(rename = "BNA - neighborhoods")]
    pub neighborhoods: f64,
    /// How well people can reach employment and educational opportunities by bike.
    #[serde(rename = "BNA - opportunity")]
    pub opportunity: f64,
    /// How well people can reach Core Services by bike.
    #[serde(rename = "BNA - essential_services")]
    #[serde(deserialize_with = "csv::invalid_option")]
    pub essential_services: Option<f64>,
    /// How well people can reach retail shopping opportunities by bike.
    #[serde(rename = "BNA - retail")]
    pub retail: f64,
    /// How well people can reach recreation opportunities by bike.
    #[serde(rename = "BNA - recreation")]
    #[serde(deserialize_with = "csv::invalid_option")]
    pub recreation: Option<f64>,
    /// How well people can reach major transit hubs by bike.
    #[serde(rename = "BNA - transit")]
    pub transit: f64,
    /// How well the bike network gets people to the places they want to go.
    #[serde(rename = "BNA - overall_score")]
    pub overall_score: f64,
}

/// Represent a city bike infrastructure.
#[derive(Debug, Deserialize, Clone)]
pub struct Infrastructure {
    /// Miles of low stress infrstructure.
    #[serde(rename = "total_low_stress_miles")]
    #[serde(deserialize_with = "csv::invalid_option")]
    pub low_stress_miles: Option<f64>,
    /// Miles of high stress infrastructure.
    #[serde(rename = "total_high_stress_miles")]
    #[serde(deserialize_with = "csv::invalid_option")]
    pub high_stress_miles: Option<f64>,
}
